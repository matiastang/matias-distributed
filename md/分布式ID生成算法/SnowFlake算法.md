<!--
 * @Author: tangdaoyong
 * @Date: 2021-02-04 09:36:55
 * @LastEditors: tangdaoyong
 * @LastEditTime: 2021-02-04 09:37:17
 * @Description: SnowFlake算法
-->
# SnowFlake算法

1）算法说明

+--------------------------------------------------------------------------+
| 1 Bit Unused | 41 Bit Timestamp |  10 Bit NodeId  |   12 Bit Sequence Id |
+--------------------------------------------------------------------------+

最高位是符号位，始终为0，不可用。

41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。

10位的机器标识，10位的长度最多支持部署1024个节点。

12位的计数序列号，序列号即一系列的自增ID，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。

2）算法总结

优点：

完全是一个无状态机，无网络调用，高效可靠。

缺点：

依赖机器时钟，如果时钟错误比如时钟回拨，可能会产生重复Id。
容量存在局限性，41位的长度可以使用69年，一般够用。
并发局限性，每毫秒单机最大产生4096个Id。
只适用于int64类型的Id分配，int32位Id无法使用。

3）适用场景

一般的非Web应用程序的int64类型的Id都可以使用。

为什么说非Web应用，Web应用为什么不可以用呢，因为JavaScript支持的最大整型就是53位，超过这个位数，JavaScript将丢失精度。